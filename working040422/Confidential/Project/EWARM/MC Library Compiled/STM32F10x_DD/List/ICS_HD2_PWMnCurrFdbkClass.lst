###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        27/Jan/2017  12:47:03
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\JOHNS MOTOR STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\MCLibrary\src\ICS_HD2_PWMnCurrFdbkClass.c
#    Command line =  
#        "C:\JOHNS MOTOR STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\MCLibrary\src\ICS_HD2_PWMnCurrFdbkClass.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_HD -D MC_LIBRARY_DUAL -lcN "C:\JOHNS
#        MOTOR STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\MC Library
#        Compiled\STM32F10x_DD\List" -o "C:\JOHNS MOTOR STUFF\EA082 Baseline on
#        LIBv4.2 - MA302\Confidential\Project\EWARM\MC Library
#        Compiled\STM32F10x_DD\Obj" --debug --endian=little --cpu=Cortex-M3 -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I "C:\JOHNS MOTOR
#        STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\..\" -I "C:\JOHNS MOTOR STUFF\EA082
#        Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\..\..\MCLibrary\" -I "C:\JOHNS MOTOR
#        STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\..\..\MCLibrary\inc\" -I "C:\JOHNS
#        MOTOR STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\..\..\MCLibrary\interface\" -I
#        "C:\JOHNS MOTOR STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\..\..\MCLibrary\interface\common\" -I
#        "C:\JOHNS MOTOR STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\..\..\..\Common\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "C:\JOHNS MOTOR STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\..\..\..\Common\Libraries\STM32F10x_StdPeriph_Driver\inc\"
#        -Oh --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        C:\JOHNS MOTOR STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\MC Library
#        Compiled\STM32F10x_DD\List\ICS_HD2_PWMnCurrFdbkClass.lst
#    Object file  =  
#        C:\JOHNS MOTOR STUFF\EA082 Baseline on LIBv4.2 -
#        MA302\Confidential\Project\EWARM\MC Library
#        Compiled\STM32F10x_DD\Obj\ICS_HD2_PWMnCurrFdbkClass.o
#
###############################################################################

C:\JOHNS MOTOR STUFF\EA082 Baseline on LIBv4.2 - MA302\Confidential\MCLibrary\src\ICS_HD2_PWMnCurrFdbkClass.c
      1          /**
      2            ******************************************************************************
      3            * @file    ICS_HD2_PWMnCurrFdbkClass.c
      4            * @author  STMicroelectronics - System Lab - MC Team
      5            * @version 4.2.0
      6            * @date    20-Aug-2015 18:06
      7            * @brief   This file contains private implementation of current sensor class in 
      8            *          case of dual motors and in case ICS and STM32F103 High Density is 
      9            *          used           
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     14            *
     15            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     16            * You may not use this file except in compliance with the License.
     17            * You may obtain a copy of the License at:
     18            *
     19            *        http://www.st.com/software_license_agreement_liberty_v2
     20            *
     21            * Unless required by applicable law or agreed to in writing, software 
     22            * distributed under the License is distributed on an "AS IS" BASIS, 
     23            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     24            * See the License for the specific language governing permissions and
     25            * limitations under the License.
     26            *
     27            ******************************************************************************
     28            */
     29          
     30          #if (STM32F10X_HD)
     31          
     32          /* Includes ------------------------------------------------------------------*/
     33          #include "PWMnCurrFdbkClass.h"
     34          #include "PWMnCurrFdbkPrivate.h"
     35          #include "ICS_HD2_PWMnCurrFdbkClass.h"
     36          #include "ICS_HD2_PWMnCurrFdbkPrivate.h"
     37          #include "MCIRQHandlerClass.h"
     38          #include "MCIRQHandlerPrivate.h"
     39          #include "MCLibraryConf.h"
     40          #include "MCLibraryISRPriorityConf.h"
     41          #include "MC_type.h"
     42          
     43          /* ADC1 Data Register address */
     44          #define ADC1_DR_Address     0x4001244Cu
     45          
     46          /* ADC SMPx mask */
     47          #define SMPR1_SMP_Set              ((uint32_t) (0x00000007u))
     48          #define SMPR2_SMP_Set              ((uint32_t) (0x00000007u))
     49          /* Bit Banding */
     50          #define ADC1_CR2_EXTTRIG_SWSTART_BB             0x42248158u
     51          
     52          #define TIMxCCER_MASK              ((uint16_t)  ~0x1555u)
     53          #define TIMxCCER_MASK_CH123        ((uint16_t)  0x555u)
     54          
     55          #define TIMx_CC4E_BIT              ((uint16_t)  0x1000u) 
     56          
     57          #define CONV_STARTED               ((uint32_t) (0x8))
     58          #define CONV_FINISHED              ((uint32_t) (0xC))
     59          #define FLAGS_CLEARED              ((uint32_t) (0x0))
     60          #define ADC_SR_MASK                ((uint32_t) (0xC))
     61          
     62          #define ADC_RIGHT_ALIGNMENT 3u
     63          
     64          #define NB_CONVERSIONS 16u
     65          
     66          #define CLASS_VARS   ((_CPWMC)this)->Vars_str
     67          #define DCLASS_PARAMS ((_DCIHD2_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str
     68          #define DCLASS_VARS  ((_DCIHD2_PWMC)(((_CPWMC) this)->DerivedClass))->DVars_str
     69          
     70          #ifdef MC_CLASS_DYNAMIC
     71          #include "stdlib.h" /* Used for dynamic allocation */
     72          #else
     73          _DCIHD2_PWMC_t IHD2_PWMCpool[MAX_DRV_PWMC_NUM];
     74          unsigned char IHD2_PWMC_Allocated = 0u;
     75          #endif
     76          
     77          /*#define DEBUG*/
     78          
     79          #ifdef DEBUG
     80          static volatile _CPWMC oPWMCdbg;
     81          static volatile _DCIHD2_PWMC oIHD2dbg;
     82          #endif
     83          
     84          static void IHD2_Init(CPWMC this);
     85          static void IHD2_TIMxInit(TIM_TypeDef* TIMx, CPWMC this);
     86          static void IHD2_CurrentReadingCalibration(CPWMC this);
     87          static void IHD2_GetPhaseCurrents(CPWMC this,Curr_Components* pStator_Currents);
     88          static void IHD2_TurnOnLowSides(CPWMC this);
     89          static void IHD2_SwitchOnPWM(CPWMC this);
     90          static void IHD2_SwitchOffPWM(CPWMC this);
     91          static uint16_t IHD2_WriteTIMRegisters(CPWMC this);   
     92          static void *IHD2_IRQHandler(void *this, unsigned char flag);
     93          static uint16_t IHD2_ExecRegularConv(CPWMC this, uint8_t bChannel);
     94          static void IHD2_ADC_SetSamplingTime(CPWMC this, ADConv_t ADConv_struct);
     95          static void IHD2_HFCurrentsCalibration(CPWMC this,Curr_Components* pStator_Currents);
     96          static uint16_t IHD2_IsOverCurrentOccurred(CPWMC this);
     97          
     98          /**
     99          * @brief  Creates an object of the class ICS_HD2
    100          * @param  pPWMnCurrFdbkParams pointer to an PWMnCurrFdbk parameters structure
    101          * @param  pICS_DDParams pointer to an ICS_DD parameters structure
    102          * @retval CIHD2_PWMC new instance of ICS_HD2 object
    103          */
    104          CIHD2_PWMC IHD2_NewObject(pPWMnCurrFdbkParams_t pPWMnCurrFdbkParams, 
    105                                              pICS_DDParams_t pICS_DDParams)
    106          {
    107            _CPWMC _oPWMnCurrFdbk;
    108            _DCIHD2_PWMC _oICS_HD2;
    109            
    110            _oPWMnCurrFdbk = (_CPWMC)PWMC_NewObject(pPWMnCurrFdbkParams);
    111            
    112          #ifdef MC_CLASS_DYNAMIC
    113            _oICS_HD2 = (_DCIHD2_PWMC)calloc(1u,sizeof(_DCIHD2_PWMC_t));
    114          #else
    115            if (IHD2_PWMC_Allocated  < MAX_DRV_PWMC_NUM)
    116            {
    117              _oICS_HD2 = &IHD2_PWMCpool[IHD2_PWMC_Allocated++];
    118            }
    119            else
    120            {
    121              _oICS_HD2 = MC_NULL;
    122            }
    123          #endif
    124            
    125            _oICS_HD2->pDParams_str = pICS_DDParams;
    126            _oPWMnCurrFdbk->DerivedClass = (void*)_oICS_HD2;
    127            
    128            _oPWMnCurrFdbk->Methods_str.pIRQ_Handler = &IHD2_IRQHandler;
    129            
    130            Set_IRQ_Handler(pICS_DDParams->IRQnb, (_CMCIRQ)_oPWMnCurrFdbk);
    131            
    132            _oPWMnCurrFdbk->Methods_str.pPWMC_Init = &IHD2_Init;
    133            _oPWMnCurrFdbk->Methods_str.pPWMC_GetPhaseCurrents = &IHD2_GetPhaseCurrents;
    134            _oPWMnCurrFdbk->Methods_str.pPWMC_SwitchOffPWM = &IHD2_SwitchOffPWM;
    135            _oPWMnCurrFdbk->Methods_str.pPWMC_SwitchOnPWM = &IHD2_SwitchOnPWM;        
    136            _oPWMnCurrFdbk->Methods_str.pPWMC_CurrentReadingCalibr = 
    137                                                           &IHD2_CurrentReadingCalibration;         
    138            _oPWMnCurrFdbk->Methods_str.pPWMC_TurnOnLowSides = &IHD2_TurnOnLowSides;         
    139            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect1 = 
    140                                                                &IHD2_WriteTIMRegisters;        
    141            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect2 = 
    142                                                                &IHD2_WriteTIMRegisters; 
    143            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect3 = 
    144                                                                &IHD2_WriteTIMRegisters;        
    145            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect4 = 
    146                                                                &IHD2_WriteTIMRegisters;         
    147            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect5 = 
    148                                                                &IHD2_WriteTIMRegisters;        
    149            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect6 = 
    150                                                                &IHD2_WriteTIMRegisters; 
    151            _oPWMnCurrFdbk->Methods_str.pPWMC_ExecRegularConv= &IHD2_ExecRegularConv;
    152            
    153            _oPWMnCurrFdbk->Methods_str.pPWMC_SetSamplingTime= &IHD2_ADC_SetSamplingTime;
    154            
    155            _oPWMnCurrFdbk->Methods_str.pPWMC_IsOverCurrentOccurred = 
    156              &IHD2_IsOverCurrentOccurred;
    157            
    158            return ((CIHD2_PWMC)_oPWMnCurrFdbk);
    159          }
    160          
    161          /** @addtogroup STM32F10x_PMSM_MC_Library
    162          * @{
    163          */
    164          
    165          /** @addtogroup PWMnCurrFdbk_ICS_HD2
    166          * @{
    167          */
    168          
    169          /** @defgroup ICS_HD2_class_private_methods ICS_HD2 class private methods
    170          * @{
    171          */
    172          
    173          /**
    174          * @brief  It initializes TIMx, ADC, GPIO, DMA1 and NVIC for current reading 
    175          *         in ICS configuration using STM32F103x High Density
    176          * @param  this: related object of class CIHD2_PWMC
    177          * @retval none
    178          */
    179          static void IHD2_Init(CPWMC this)
    180          {
    181            DMA_InitTypeDef DMA_InitStructure;
    182            NVIC_InitTypeDef NVIC_InitStructure;
    183            GPIO_InitTypeDef GPIO_InitStructure;
    184            ADC_InitTypeDef ADC_InitStructure;
    185            uint16_t hAux;
    186            pVars_t pVars_str = &CLASS_VARS;
    187            pDVars_t pDVars_str = &DCLASS_VARS;  
    188            pDParams_t pDParams_str = DCLASS_PARAMS; 
    189            uint32_t wAux1, wAux2, wAux3, wAux4;
    190            
    191            pDVars_str->Half_PWMPeriod = ((((_CPWMC) this)->pParams_str->hPWMperiod)/2u);
    192            pVars_str->bMotor = (pDParams_str->bInstanceNbr==1u?M1:M2);
    193              
    194            /* Peripheral clocks enabling ---------------------------------------------*/
    195            
    196            RCC->AHBENR |= RCC_AHBPeriph_CRC;
    197            
    198            /* ADCCLK = PCLK2 */
    199            RCC_ADCCLKConfig(pDParams_str ->wADC_Clock_Divider);
    200            /* Enable ADC1 clock */
    201            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    202            /* Enable ADC2 clock */
    203            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE); 
    204            /* Enable GPIOA-GPIOF clock */
    205            RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA | 
    206                                   RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | 
    207                                     RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | 
    208                                       RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG, ENABLE);  
    209            
    210            /* Enable the CCS */
    211            RCC_ClockSecuritySystemCmd((FunctionalState)(ENABLE));
    212            
    213             /* Enable DMA1 clock */
    214            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); 
    215            
    216            if(pDParams_str->TIMx == TIM1)
    217            {
    218              /* Enable TIM1 clock */
    219              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
    220            }
    221            else
    222            {
    223              /* Enable TIM8 clock */
    224              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
    225            }
    226            
    227            /* GPIOs configurations --------------------------------------------------*/
    228            GPIO_StructInit(&GPIO_InitStructure);
    229            
    230            /****** Configure phase A ADC channel GPIO as analog input ****/
    231            GPIO_InitStructure.GPIO_Pin = pDParams_str->hIaPin;  
    232            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    233            GPIO_Init(pDParams_str->hIaPort,
    234                      &GPIO_InitStructure);
    235            GPIO_PinLockConfig(pDParams_str->hIaPort, pDParams_str->hIaPin);
    236            
    237            /****** Configure phase B ADC channel GPIO as analog input ****/
    238            GPIO_InitStructure.GPIO_Pin = pDParams_str->hIbPin;  
    239            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    240            GPIO_Init(pDParams_str->hIbPort, &GPIO_InitStructure);
    241            GPIO_PinLockConfig(pDParams_str->hIbPort, pDParams_str->hIbPin);
    242            
    243            /* Alternate function remapping available only for TIM1 */
    244            if(pDParams_str->TIMx == TIM1)
    245            {     
    246              /****** Timer1 alternate function full remapping ******/  
    247              if((pDParams_str-> wTIM1Remapping) != GPIO_NoRemap_TIM1)
    248              {   
    249                GPIO_PinRemapConfig(pDParams_str->wTIM1Remapping, ENABLE);  
    250              }  
    251            }
    252            
    253            /****** Configure TIMx Channel 1, 2 and 3 Outputs ******/ 
    254            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    255            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    256            
    257            hAux = (pDParams_str->hCh1Pin) | (pDParams_str->hCh2Pin);  
    258            hAux = hAux | (pDParams_str->hCh3Pin);  
    259            GPIO_InitStructure.GPIO_Pin = hAux; 
    260            GPIO_Init(pDParams_str->hCh1Port, &GPIO_InitStructure);
    261            GPIO_PinLockConfig(pDParams_str->hCh1Port, hAux);
    262            
    263            /****** Configure TIMx Channel 1N, 2N and 3N Outputs, if enabled ******/    
    264            if ((pDParams_str->LowSideOutputs)== LS_PWM_TIMER)
    265            { 
    266              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh1NPin;  
    267              GPIO_Init(pDParams_str->hCh1NPort, &GPIO_InitStructure);  
    268              GPIO_PinLockConfig(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin);
    269              
    270              hAux = (pDParams_str->hCh2NPin) | (pDParams_str->hCh3NPin);
    271              GPIO_InitStructure.GPIO_Pin = hAux; 
    272              GPIO_Init(pDParams_str->hCh2NPort, &GPIO_InitStructure);
    273              GPIO_PinLockConfig(pDParams_str->hCh2NPort, hAux);    
    274            }  else if ((pDParams_str->LowSideOutputs)== ES_GPIO)
    275            {
    276              /* Only "active high" polarity is supported */
    277              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    278              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh1NPin;  
    279              GPIO_Init(pDParams_str->hCh1NPort, &GPIO_InitStructure);  
    280              GPIO_PinLockConfig(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin);
    281              
    282              hAux = (pDParams_str->hCh2NPin) | (pDParams_str->hCh3NPin);
    283              GPIO_InitStructure.GPIO_Pin = hAux; 
    284              GPIO_Init(pDParams_str->hCh2NPort, &GPIO_InitStructure);    
    285              GPIO_PinLockConfig(pDParams_str->hCh2NPort, hAux);
    286            }
    287            else
    288            {
    289            }
    290            
    291            if ((pDParams_str->EmergencyStop)!= DISABLE)  
    292            {
    293              /****** Configure TIMx BKIN input, if enabled ******/   
    294              GPIO_StructInit(&GPIO_InitStructure);
    295              GPIO_InitStructure.GPIO_Pin = pDParams_str->hBKINPin;  
    296              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    297              GPIO_Init(pDParams_str->hBKINPort, &GPIO_InitStructure); 
    298              GPIO_PinLockConfig(pDParams_str->hBKINPort, pDParams_str->hBKINPin);
    299            }
    300            
    301            
    302            IHD2_TIMxInit(pDParams_str->TIMx, this);
    303            
    304            if(pDParams_str->TIMx == TIM1)
    305            {   
    306              /* TIM1 Counter Clock stopped when the core is halted */
    307              DBGMCU_Config(DBGMCU_TIM1_STOP, ENABLE);
    308            }
    309            else
    310            {
    311              /* TIM8 Counter Clock stopped when the core is halted */
    312              DBGMCU_Config(DBGMCU_TIM8_STOP, ENABLE);
    313            }
    314            
    315            /* It saves the sampling time settings before DeInit in case of second instance */  
    316            wAux1 = ADC1->SMPR1;
    317            wAux2 = ADC1->SMPR2;
    318            wAux3 = ADC2->SMPR1;
    319            wAux4 = ADC2->SMPR2;
    320            
    321            /* ADC1 and ADC2 registers configuration ---------------------------------*/
    322            /* ADC1 and ADC2 registers reset */  
    323            ADC_DeInit(ADC1);
    324            ADC_DeInit(ADC2);
    325          
    326            /* ADC1 and ADC2 registers configuration ---------------------------------*/
    327            /* Enable ADC1 and ADC2 */
    328            ADC_Cmd(ADC1, ENABLE);
    329            ADC_Cmd(ADC2, ENABLE);
    330          
    331            
    332            ADC1->SMPR1 = wAux1;
    333            ADC1->SMPR2 = wAux2;  
    334            ADC2->SMPR1 = wAux3;
    335            ADC2->SMPR2 = wAux4;
    336            
    337            /* ADC Init */
    338            ADC_StructInit(&ADC_InitStructure);
    339            ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    340            ADC_InitStructure.ADC_ScanConvMode = DISABLE;
    341            ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
    342            ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    343            ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left;
    344            ADC_InitStructure.ADC_NbrOfChannel = 1u;
    345            ADC_Init(ADC1, &ADC_InitStructure);
    346            ADC_Init(ADC2, &ADC_InitStructure);
    347            
    348            ADC_InjectedDiscModeCmd(ADC1, ENABLE);
    349            ADC_InjectedDiscModeCmd(ADC2, ENABLE);
    350          
    351            /* Enable external trigger (it will be SW) for ADC1 and ADC2 regular 
    352            conversions */ 
    353            ADC_ExternalTrigConvCmd(ADC1, ENABLE);
    354            ADC_ExternalTrigConvCmd(ADC2, ENABLE);
    355            
    356            /* Remap of Eternal trigger of ADC1 and 2 into TIM8 CH4 */
    357            GPIO_PinRemapConfig(GPIO_Remap_ADC1_ETRGINJ, ENABLE);
    358            GPIO_PinRemapConfig(GPIO_Remap_ADC2_ETRGINJ, ENABLE);
    359              
    360            /* Start calibration of ADC1 and ADC2 */
    361            ADC_StartCalibration(ADC1);
    362            ADC_StartCalibration(ADC2);
    363            
    364            /* Wait for the end of ADCs calibration */
    365            while (ADC_GetCalibrationStatus(ADC1) & ADC_GetCalibrationStatus(ADC2))
    366            {
    367            }
    368            
    369          /* It is used only to configure the sampling time to the corresponding channel*/
    370            ADC_InjectedChannelConfig(ADC1, pDParams_str->bIaChannel, 1u,
    371                                                          pDParams_str->b_IaSamplingTime);
    372            ADC_InjectedChannelConfig(ADC2, pDParams_str->bIbChannel, 1u,
    373                                                          pDParams_str->b_IbSamplingTime);    
    374            
    375            /* DMA Event related to ADC regular conversion*/
    376            /* DMA1 channel1 configuration */
    377            DMA_DeInit(DMA1_Channel1);
    378            DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR_Address;
    379            DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)(&(pDVars_str->hRegConv));
    380            DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    381            DMA_InitStructure.DMA_BufferSize = 1u;
    382            DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    383            DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
    384            DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
    385            DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
    386            DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    387            DMA_InitStructure.DMA_Priority = DMA_Priority_Low;
    388            DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    389            DMA_Init(DMA1_Channel1, &DMA_InitStructure);
    390            /* Enable DMA1 Channel1 */
    391            DMA_Cmd(DMA1_Channel1, ENABLE);
    392            /* Enable ADC1 EOC DMA */
    393            ADC_DMACmd(ADC1,ENABLE);  
    394          
    395            /* ADC1 Injected conversions end interrupt enabling */
    396            ADC_ClearFlag(ADC1, ADC_FLAG_JEOC); 	 
    397            ADC_ITConfig(ADC1, ADC_IT_JEOC, ENABLE); 
    398            
    399            /* Enable the ADC Interrupt */
    400            NVIC_InitStructure.NVIC_IRQChannel = (uint8_t) ADC1_2_IRQn;
    401            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 
    402              ADC_PRE_EMPTION_PRIORITY;
    403            NVIC_InitStructure.NVIC_IRQChannelSubPriority = ADC_SUB_PRIORITY;
    404            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    405            NVIC_Init(&NVIC_InitStructure);
    406            
    407            if(pDParams_str->TIMx==TIM1)
    408            {
    409              /* Enable the TIM1 Update interrupt */
    410              NVIC_InitStructure.NVIC_IRQChannel = (uint8_t) TIM1_UP_IRQn;
    411              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIMx_UP_PRE_EMPTION_PRIORITY;
    412              NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIMx_UP_SUB_PRIORITY;
    413              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    414              NVIC_Init(&NVIC_InitStructure);   
    415            }
    416            else
    417            {
    418              /* Enable the TIM1 Update interrupt */
    419              NVIC_InitStructure.NVIC_IRQChannel = (uint8_t) TIM8_UP_IRQn;
    420              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIMx_UP_PRE_EMPTION_PRIORITY;
    421              NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIMx_UP_SUB_PRIORITY;
    422              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    423              NVIC_Init(&NVIC_InitStructure);     
    424            }
    425          }
    426          
    427          /**
    428          * @brief  It initializes TIMx peripheral for PWM generation
    429          * @param 'TIMx': Timer to be initialized
    430          * @param 'this': related object of class CIHD2_PWMC
    431          * @retval none
    432          */
    433          static void IHD2_TIMxInit(TIM_TypeDef* TIMx, CPWMC this)
    434          {
    435            TIM_TimeBaseInitTypeDef TIMx_TimeBaseStructure;
    436            TIM_OCInitTypeDef TIMx_OCInitStructure;
    437            TIM_BDTRInitTypeDef TIMx_BDTRInitStructure;
    438            pDVars_t pDVars_str = &DCLASS_VARS;  
    439            pDParams_t pDParams_str =DCLASS_PARAMS; 
    440            
    441            /* TIMx Peripheral Configuration -------------------------------------------*/
    442            /* TIMx Registers reset */
    443            TIM_DeInit(TIMx);
    444            TIM_TimeBaseStructInit(&TIMx_TimeBaseStructure);
    445            /* Time Base configuration */
    446            TIMx_TimeBaseStructure.TIM_Prescaler = (uint16_t)(pDParams_str->bTim_Clock_Divider) - 1u;
    447            TIMx_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_CenterAligned1;
    448            TIMx_TimeBaseStructure.TIM_Period = pDVars_str->Half_PWMPeriod;
    449            TIMx_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV2;
    450            TIMx_TimeBaseStructure.TIM_RepetitionCounter = pDParams_str->
    451                                                                      bRepetitionCounter;
    452            TIM_TimeBaseInit(TIMx, &TIMx_TimeBaseStructure);
    453            
    454            /* Channel 1, 2,3 and 4 Configuration in PWM mode */
    455            TIM_OCStructInit(&TIMx_OCInitStructure);  
    456            TIMx_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 
    457            TIMx_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 
    458            TIMx_OCInitStructure.TIM_Pulse = pDVars_str->Half_PWMPeriod/2u; /* dummy value */
    459            
    460            /* Channel 1 */
    461            TIMx_OCInitStructure.TIM_OCPolarity = pDParams_str->hCh1Polarity;      
    462            TIMx_OCInitStructure.TIM_OCIdleState = pDParams_str->hCh1IdleState;    
    463            if ((pDParams_str->LowSideOutputs)== LS_PWM_TIMER) 
    464            {
    465              TIMx_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable; 
    466              TIMx_OCInitStructure.TIM_OCNPolarity = pDParams_str->hCh1NPolarity; 
    467              TIMx_OCInitStructure.TIM_OCNIdleState = pDParams_str->hCh1NIdleState;     
    468            }    
    469            else
    470            {
    471              TIMx_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;
    472            }    
    473            TIM_OC1Init(TIMx, &TIMx_OCInitStructure); 
    474            
    475            
    476            /* Channel 2 */
    477            TIMx_OCInitStructure.TIM_OCPolarity = pDParams_str->hCh2Polarity;      
    478            TIMx_OCInitStructure.TIM_OCIdleState = pDParams_str->hCh2IdleState;    
    479            if ((pDParams_str->LowSideOutputs)== LS_PWM_TIMER)
    480            {
    481            TIMx_OCInitStructure.TIM_OCNPolarity = pDParams_str->hCh2NPolarity; 
    482            TIMx_OCInitStructure.TIM_OCNIdleState = pDParams_str->hCh2NIdleState;         
    483            }
    484            TIM_OC2Init(TIMx, &TIMx_OCInitStructure); 
    485            
    486            
    487            /* Channel 3 */
    488            TIMx_OCInitStructure.TIM_OCPolarity = pDParams_str->hCh3Polarity;      
    489            TIMx_OCInitStructure.TIM_OCIdleState = pDParams_str->hCh3IdleState;    
    490            if ((pDParams_str->LowSideOutputs)== LS_PWM_TIMER)
    491            {
    492            TIMx_OCInitStructure.TIM_OCNPolarity = pDParams_str->hCh3NPolarity; 
    493            TIMx_OCInitStructure.TIM_OCNIdleState = pDParams_str->hCh3NIdleState;         
    494            }
    495            TIM_OC3Init(TIMx, &TIMx_OCInitStructure);   
    496            
    497              /* Channel 4 */
    498            TIMx_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
    499            TIMx_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;      
    500            TIMx_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset; 
    501            TIMx_OCInitStructure.TIM_Pulse = DCLASS_VARS.Half_PWMPeriod+1u;
    502            TIM_OC4Init(TIMx, &TIMx_OCInitStructure); 
    503            
    504            /* Enables the TIMx Preload on CC1 Register */
    505            TIM_OC1PreloadConfig(TIMx, TIM_OCPreload_Enable);
    506            /* Enables the TIMx Preload on CC2 Register */
    507            TIM_OC2PreloadConfig(TIMx, TIM_OCPreload_Enable);
    508            /* Enables the TIMx Preload on CC3 Register */
    509            TIM_OC3PreloadConfig(TIMx, TIM_OCPreload_Enable);
    510            /* Enables the TIMx Preload on CC4 Register */
    511            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Enable); 
    512            
    513            TIM_BDTRStructInit(&TIMx_BDTRInitStructure);
    514            /* Dead Time */
    515            TIMx_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
    516            TIMx_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
    517            TIMx_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1; 
    518            TIMx_BDTRInitStructure.TIM_DeadTime = (pDParams_str->hDeadTime)/2u;
    519            /* BKIN, if enabled */
    520            if ((pDParams_str->EmergencyStop)!= DISABLE)  
    521            {
    522              TIMx_BDTRInitStructure.TIM_Break = TIM_Break_Enable;
    523              TIMx_BDTRInitStructure.TIM_BreakPolarity = pDParams_str->hBKINPolarity;
    524              TIMx_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
    525              TIM_ClearITPendingBit(TIMx, TIM_IT_Break);
    526              TIM_ITConfig(TIMx, TIM_IT_Break, ENABLE);
    527            }  
    528            TIM_BDTRConfig(TIMx, &TIMx_BDTRInitStructure);
    529           
    530            TIM_SelectInputTrigger(TIMx,TIM_TS_ITR1);
    531            TIM_SelectSlaveMode(TIMx,TIM_SlaveMode_Trigger);
    532          
    533            /* Prepare timer for synchronization */
    534            TIM_GenerateEvent(TIMx,TIM_EventSource_Update);
    535                
    536            if (pDParams_str->bFreqRatio == 2u) 
    537            {
    538              if (pDParams_str->bIsHigherFreqTim == HIGHER_FREQ)
    539              {
    540                if (pDParams_str->bRepetitionCounter == 3u)
    541                {
    542                  /* Set TIMx repetition counter to 1 */
    543                  TIMx->RCR =0x01u; 
    544                  TIM_GenerateEvent(TIMx, TIM_EventSource_Update);
    545                  /* Repetition counter will be set to 3 at next Update */
    546                  TIMx->RCR =0x03u; 
    547                }
    548              }
    549              
    550              TIM_SetCounter(TIMx, pDVars_str->Half_PWMPeriod-1u);     
    551            }
    552            else /* bFreqRatio equal to 1 or 3 */
    553            {
    554              if (pDParams_str->bInstanceNbr == 1u)
    555              {
    556                TIM_SetCounter(TIMx, pDVars_str->Half_PWMPeriod-1u);
    557              }
    558            }
    559          }
    560          
    561          /**
    562          * @brief  It perform the start of all the timers required by the control. 
    563                    It utilizes TIM2 as temporary timer to achieve synchronization between 
    564                    PWM signals.
    565                    When this function is called, TIM1 and/or TIM8 must be in frozen state
    566                    with CNT, ARR, REP RATE and trigger correctly set (these setting are 
    567                    usually performed in the Init method accordingly with the configuration)
    568          * @param  none
    569          * @retval none
    570          */
    571           void IHD2_StartTimers(void)
    572          {
    573           TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;   
    574            
    575            /* Temporary Enable TIM2 clock */
    576            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    577            TIM_DeInit(TIM2);
    578            TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
    579            /* Time Base configuration */
    580            TIM_TimeBaseStructure.TIM_Prescaler = 0x0u;
    581            TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    582            TIM_TimeBaseStructure.TIM_Period = 1u; /* dummy */ 
    583            TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    584            TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
    585            
    586            TIM_SelectOutputTrigger(TIM2, TIM_TRGOSource_Update);  
    587               
    588            TIM_Cmd(TIM2, ENABLE);
    589            
    590            TIM_DeInit(TIM2);
    591            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, DISABLE); 
    592          }
    593          
    594          
    595          /**
    596          * @brief  It stores into 'this' object variables the voltage present on Ia and 
    597          *         Ib current feedback analog channels when no current is flowin into the
    598          *         motor
    599          * @param  this: related object of class CIHD2_PWMC
    600          * @retval none
    601          */
    602          static void IHD2_CurrentReadingCalibration(CPWMC this)
    603          {
    604            pDVars_t pDVars_str = &DCLASS_VARS; 
    605            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;    
    606            uint16_t htempCCER, haux;
    607            
    608            pDVars_str-> wPhaseAOffset = 0u;
    609            pDVars_str-> wPhaseBOffset = 0u; 
    610            
    611            pDVars_str->bIndex=0u;
    612            
    613            /* Force inactive level on TIMx CHy and TIMx CHyN */ 
    614            htempCCER =  DCLASS_PARAMS->TIMx->CCER;
    615            haux = htempCCER & TIMxCCER_MASK;
    616            haux |= TIMx_CC4E_BIT;
    617            LocalTIMx->CCER = haux;
    618            
    619            /* Change function to be executed in ADCx_ISR */ 
    620            ((_CPWMC) this)->Methods_str.pPWMC_GetPhaseCurrents = &IHD2_HFCurrentsCalibration;
    621            
    622            IHD2_SwitchOnPWM(this);
    623            
    624            /* Wait for NB_CONVERSIONS to be executed */
    625            while (pDVars_str->bIndex < (NB_CONVERSIONS))
    626            {
    627              if (LocalTIMx->DIER & TIM_IT_Update)
    628              {}
    629              else
    630              {
    631                pDVars_str->bIndex = NB_CONVERSIONS;
    632              }
    633            }  
    634            
    635            IHD2_SwitchOffPWM( this);
    636            
    637            pDVars_str->wPhaseAOffset >>=3; 
    638            pDVars_str->wPhaseBOffset >>=3; 
    639           
    640            /* It over write TIMx CCRy wrongly written by FOC during calibration so as to 
    641             force 50% duty cycle on the three inverer legs */
    642            /* Disable TIMx preload */ 
    643            LocalTIMx->CCMR1 &= 0xF7F7u;
    644            LocalTIMx->CCMR2 &= 0xF7F7u;
    645            LocalTIMx->CCR1 = pDVars_str->Half_PWMPeriod;
    646            LocalTIMx->CCR2 = pDVars_str->Half_PWMPeriod;
    647            LocalTIMx->CCR3 = pDVars_str->Half_PWMPeriod;
    648            
    649            /* Enable TIMx preload */
    650            LocalTIMx->CCMR1 |= 0x0808u;
    651            LocalTIMx->CCMR2 |= 0x0808u;
    652            
    653            /* Set back TIMx CCER register */ 
    654            LocalTIMx->CCER = htempCCER;
    655          
    656            /* Change back function to be executed in ADCx_ISR */ 
    657            ((_CPWMC) this)->Methods_str.pPWMC_GetPhaseCurrents = &IHD2_GetPhaseCurrents;
    658          }
    659          
    660          /**
    661          * @brief  It computes and return latest converted motor phase currents motor
    662          * @param  this: related object of class CIHD2_PWMC
    663          * @retval Ia and Ib current in Curr_Components format
    664          */
    665          static void IHD2_GetPhaseCurrents(CPWMC this,Curr_Components* pStator_Currents)
    666          {
    667            int32_t wAux;
    668            uint16_t hReg;
    669            /* Derived class members container */
    670            pDVars_t pDVars_str = &DCLASS_VARS;  
    671          
    672            /* Reset the SOFOC flag to indicate the start of FOC algorithm*/
    673            pDVars_str->hFlags &= (~SOFOC); 
    674            
    675           /* Ia = (hPhaseAOffset)-(PHASE_A_ADC_CHANNEL vale)  */
    676            hReg = (uint16_t)((ADC1->JDR1)<<1);
    677            wAux = (int32_t)(hReg)-(int32_t)(pDVars_str->wPhaseAOffset);
    678            
    679           /* Saturation of Ia */
    680            if (wAux < S16_MIN)
    681            {
    682              pStator_Currents->qI_Component1= S16_MIN;
    683            }  
    684            else  if (wAux > S16_MAX)
    685                  { 
    686                    pStator_Currents->qI_Component1= S16_MAX;
    687                  }
    688                  else
    689                  {
    690                    pStator_Currents->qI_Component1= (int16_t)wAux;
    691                  }
    692                               
    693           /* Ib = (hPhaseBOffset)-(PHASE_B_ADC_CHANNEL value) */
    694            hReg = (uint16_t)((ADC2->JDR1)<<1);
    695            wAux = (int32_t)(hReg)-(int32_t)(pDVars_str->wPhaseBOffset);
    696            
    697           /* Saturation of Ib */
    698            if (wAux < S16_MIN)
    699            {
    700              pStator_Currents->qI_Component2= S16_MIN;
    701            }  
    702            else  if (wAux > S16_MAX)
    703                  { 
    704                    pStator_Currents->qI_Component2= S16_MAX;
    705                  }
    706                  else
    707                  {
    708                    pStator_Currents->qI_Component2= (int16_t)wAux;
    709                  }
    710          }
    711          
    712          
    713          /**
    714          * @brief  It sum up injected conversion data into wPhaseXOffset. It is called 
    715          *         only during current calibration 
    716          * @param  this: related object of class CIHD2_PWMC
    717          * @retval It always returns {0,0} in Curr_Components format
    718          */
    719          static void IHD2_HFCurrentsCalibration(CPWMC this,Curr_Components* pStator_Currents)
    720          { 
    721            /* Derived class members container */
    722            pDVars_t pDVars_str = &DCLASS_VARS; 
    723          
    724           /* Reset the SOFOC flag to indicate the start of FOC algorithm*/
    725            pDVars_str->hFlags &= (~SOFOC); 
    726              
    727            if (pDVars_str->bIndex < NB_CONVERSIONS)
    728            {
    729              pDVars_str-> wPhaseAOffset += ADC1->JDR1;
    730              pDVars_str-> wPhaseBOffset += ADC2->JDR1; 
    731              pDVars_str->bIndex++;
    732            }
    733          }
    734          
    735          /**
    736            * @brief  It turns on low sides switches. This function is intended to be 
    737            *         used for charging boot capacitors of driving section. It has to be 
    738            *         called each motor start-up when using high voltage drivers
    739            * @param  this: related object of class CIHD2_PWMC
    740            * @retval none
    741            */
    742          static void IHD2_TurnOnLowSides(CPWMC this)
    743          {
    744            pDParams_t pLocalDParams = DCLASS_PARAMS;
    745            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;  
    746            pDVars_t pDVars_str = &DCLASS_VARS;  
    747          
    748            /*Turn on the three low side switches */
    749            LocalTIMx->CCR1 = 0u;
    750            LocalTIMx->CCR2 = 0u;
    751            LocalTIMx->CCR3 = 0u;
    752            /*Disable ADC trigger */
    753            LocalTIMx->CCMR2 =0x7068u;
    754            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod+1u;
    755            
    756            pDVars_str->hFlags &= (~SOFOC);
    757            
    758            TIM_ClearFlag(LocalTIMx,TIM_FLAG_Update);
    759            while (TIM_GetFlagStatus(LocalTIMx,TIM_FLAG_Update) == RESET)
    760            {}
    761            
    762            /* Main PWM Output Enable */
    763            TIM_CtrlPWMOutputs(LocalTIMx, ENABLE);
    764            if ((pLocalDParams->LowSideOutputs)== ES_GPIO)
    765            {
    766              GPIO_WriteBit(pLocalDParams->hCh1NPort, pLocalDParams->hCh1NPin, Bit_SET);
    767              GPIO_WriteBit(pLocalDParams->hCh2NPort, pLocalDParams->hCh2NPin, Bit_SET);
    768              GPIO_WriteBit(pLocalDParams->hCh3NPort, pLocalDParams->hCh3NPin, Bit_SET);
    769            }
    770            return; 
    771          }
    772          
    773          
    774          /**
    775          * @brief  It enables PWM generation on the proper Timer peripheral acting on MOE
    776          *         bit
    777          * @param  this: related object of class CIHD2_PWMC
    778          * @retval none
    779          */
    780          static void IHD2_SwitchOnPWM(CPWMC this)
    781          {  
    782            pDParams_t pLocalDParams = DCLASS_PARAMS;
    783            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;  
    784            pDVars_t pDVars_str = &DCLASS_VARS;  
    785           
    786            /* It clears ADCs JSTRT and JEOC bits */
    787            ADC1->SR &= ~ADC_SR_MASK;
    788            ADC2->SR &= ~ADC_SR_MASK;
    789            
    790            /* Clear Update Flag */
    791            TIM_ClearFlag(LocalTIMx, TIM_FLAG_Update);
    792            
    793            /* Enable TIMx preload and ADC trigger on next update */
    794            LocalTIMx->CCMR2 = 0x7868u;
    795            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod-5u;
    796            
    797            TIM_ITConfig(LocalTIMx, TIM_IT_Update, ENABLE);
    798            
    799            /* Main PWM Output Disable */
    800            TIM_CtrlPWMOutputs(LocalTIMx, ENABLE);
    801            if ((pLocalDParams->LowSideOutputs)== ES_GPIO)
    802            {
    803              GPIO_WriteBit(pLocalDParams->hCh1NPort, pLocalDParams->hCh1NPin, Bit_SET);
    804              GPIO_WriteBit(pLocalDParams->hCh2NPort, pLocalDParams->hCh2NPin, Bit_SET);
    805              GPIO_WriteBit(pLocalDParams->hCh3NPort, pLocalDParams->hCh3NPin, Bit_SET);
    806            }
    807            
    808            pDVars_str->hFlags &= (~SOFOC);
    809            return; 
    810          }
    811          
    812          
    813          /**
    814          * @brief  It disables PWM generation on the proper Timer peripheral acting on 
    815          *         MOE bit
    816          * @param  this: related object of class CIHD2_PWMC
    817          * @retval none
    818          */
    819          static void IHD2_SwitchOffPWM(CPWMC this)
    820          { 
    821            pDParams_t pLocalDParams = DCLASS_PARAMS;
    822            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;
    823            pDVars_t pDVars_str = &DCLASS_VARS;  
    824            
    825              /* Disable UPDATE ISR */
    826            TIM_ITConfig(LocalTIMx, TIM_IT_Update, DISABLE);  
    827            
    828            LocalTIMx->CCER &= (uint16_t)(~TIMxCCER_MASK_CH123);
    829            
    830            while (TIM_GetFlagStatus(LocalTIMx,TIM_FLAG_Update)==RESET)
    831            {
    832              if (LocalTIMx->DIER & TIM_IT_Update)
    833              { break;}
    834            }
    835             
    836              /* Main PWM Output Disable */
    837            TIM_CtrlPWMOutputs(LocalTIMx, DISABLE);
    838            if ((pLocalDParams->LowSideOutputs)== ES_GPIO)
    839            {
    840              GPIO_WriteBit(pLocalDParams->hCh1NPort, pLocalDParams->hCh1NPin, Bit_RESET);
    841              GPIO_WriteBit(pLocalDParams->hCh2NPort, pLocalDParams->hCh2NPin, Bit_RESET);
    842              GPIO_WriteBit(pLocalDParams->hCh3NPort, pLocalDParams->hCh3NPin, Bit_RESET);
    843            }
    844            LocalTIMx->CCER |= TIMxCCER_MASK_CH123; 
    845            
    846            LocalTIMx->CCMR2 =0x7068u;
    847            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod+1u;  
    848            
    849            return; 
    850          }
    851          
    852          /**
    853          * @brief  It stores into 'this' object variables the voltage present on Ia and 
    854          *         Ib current feedback analog channels when no current is flowin into the
    855          *         motor
    856          * @param  this: related object of class CIHD2_PWMC
    857          * @retval none
    858          */
    859          static uint16_t IHD2_WriteTIMRegisters(CPWMC this)
    860          {
    861            uint16_t hAux;
    862            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;
    863            /* Derived class members container */
    864            pDVars_t pDVars_str = &DCLASS_VARS;  
    865              
    866            LocalTIMx->CCR1 = ((_CPWMC) this)->Vars_str.hCntPhA;
    867            LocalTIMx->CCR2 = ((_CPWMC) this)->Vars_str.hCntPhB;
    868            LocalTIMx->CCR3 =((_CPWMC) this)->Vars_str.hCntPhC;
    869            
    870            /* Disable TIMx preload */  
    871            LocalTIMx->CCMR2 =0x7068u;
    872            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod+1u;
    873            /* Enable TIMx preload */
    874            LocalTIMx->CCMR2 = 0x7868u;
    875            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod-5u;
    876            
    877             /* Limit for update event */
    878            /* Check the status of SOFOC flag. If it is set, an update event has occurred 
    879            and thus the FOC rate is too high */
    880            if ((pDVars_str->hFlags & SOFOC) != 0u)
    881            {
    882              hAux = MC_FOC_DURATION;
    883            }
    884            else
    885            {
    886              hAux = MC_NO_ERROR;
    887            }
    888            return hAux;
    889          }
    890          
    891          
    892          
    893          /**
    894          * @brief  It contains the TIMx Update event interrupt
    895          * @param  this: related object of class CIHD2_PWMC
    896          * @retval none
    897          */
    898          static void *IHD2_IRQHandler(void *this, unsigned char flag)
    899          {
    900            uint32_t wADCInjFlags;
    901            pVars_t pVars_str = &CLASS_VARS;
    902            pDParams_t pDParams_str = DCLASS_PARAMS;
    903            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx; 
    904            pDVars_t pDVars_str = &DCLASS_VARS;  
    905            
    906           wADCInjFlags = (ADC1-> SR) & ADC_SR_MASK;
    907           
    908          if (wADCInjFlags == CONV_STARTED)
    909           {
    910             do
    911             {
    912                wADCInjFlags = (ADC1-> SR) & ADC_SR_MASK;
    913             }
    914             while (wADCInjFlags != CONV_FINISHED);
    915           }
    916          else if (wADCInjFlags == FLAGS_CLEARED)
    917          {
    918            while ((LocalTIMx->CNT) < (pDParams_str->Tw))
    919            {}
    920            wADCInjFlags = (ADC1-> SR) & ADC_SR_MASK;
    921            
    922            if (wADCInjFlags == CONV_STARTED)
    923           {
    924             do
    925             {
    926                wADCInjFlags = (ADC1-> SR) & ADC_SR_MASK;
    927             }
    928             while (wADCInjFlags != CONV_FINISHED);
    929           }
    930          }
    931          else {}
    932          
    933          /* Set the SOFOC flag to indicate the execution of Update IRQ*/
    934          pDVars_str->hFlags |= SOFOC;
    935          
    936          /* Switch Context */
    937          /* It re-initilize AD converter in run time when using dual MC */
    938          if(LocalTIMx == TIM8)
    939          { 
    940            /* ADCx Injected conversions trigger is swithced to TIM8 CH4  
    941            ADC_ExternalTrigInjectedConvConfig(ADC2, ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4);*/ 
    942          
    943            ADC1->CR2 = 0x1EE901u;
    944            ADC2->CR2 = 0x1EE901u;
    945          }
    946          else
    947          { 
    948            /* ADCx Injected conversions trigger is swithced to TIM8 CH4  
    949            ADC_ExternalTrigInjectedConvConfig(ADC2, ADC_ExternalTrigInjecConv_T1_CC4);*/ 
    950              ADC1->CR2 = 0x1E9901u;
    951              ADC2->CR2 = 0x1E9901u;
    952          }
    953          /* Change channels keeping equal to 1 element the sequencer lenght */ 
    954          ADC1->JSQR = (uint32_t)(pDParams_str->bIaChannel)<<15;
    955          ADC2->JSQR = (uint32_t)(pDParams_str->bIbChannel)<<15;  
    956          
    957          return &(pVars_str->bMotor);
    958          }
    959          
    960          /**
    961          * @brief  Execute a regular conversion using ADC1. 
    962          *         The function is not re-entrant (can't executed twice at the same time)
    963          * @param  this related object of class CIHD2_PWMC
    964          * @retval It returns converted value or oxFFFF for conversion error
    965          */
    966          static uint16_t IHD2_ExecRegularConv(CPWMC this, uint8_t bChannel)
    967          {
    968            pDVars_t pDVars_str = &DCLASS_VARS;
    969            uint32_t tmpflag = 0u;
    970          
    971            ADC1->SQR3 = bChannel;
    972            
    973            DMA1_Channel1->CMAR=(uint32_t)(&(pDVars_str->hRegConv));
    974            
    975            /* Reset DMA1_CH1 TC Flag */
    976            DMA1->IFCR = DMA1_FLAG_TC1;
    977            
    978            /* It starts software triggered regular conversion
    979            through bit banding access. It is equivalent to 
    980            ADC1->CR2 |= EXTTRIG_SWSTART_Set; */
    981            *(uint32_t *)(ADC1_CR2_EXTTRIG_SWSTART_BB)=(uint32_t)(0x1u);
    982            
    983            /* Wait until end of regular conversion */
    984            while (tmpflag == 0u)
    985            {
    986              tmpflag = (DMA1->ISR & DMA1_FLAG_TC1);
    987            }
    988           
    989            return (pDVars_str->hRegConv);
    990          }
    991          
    992          /**
    993          * @brief  It sets the specified sampling time for the specified ADC channel
    994          *         on ADC1. It must be called once for each channel utilized by user
    995          * @param  ADC channel, sampling time
    996          * @retval none
    997          */
    998          static void IHD2_ADC_SetSamplingTime(CPWMC this, ADConv_t ADConv_struct)
    999          { 
   1000             uint32_t tmpreg1 = 0u, tmpreg2 = 0u, tmpreg3=0u, tmpreg4 = SMPR1_SMP_Set;
   1001             
   1002            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
   1003            if (ADConv_struct.Channel> ADC_Channel_9)
   1004            {
   1005              /* Get the old register value */
   1006              tmpreg1 = ADC1->SMPR1;
   1007              /* Calculate the mask to clear */
   1008              tmpreg3 = (uint32_t) (ADConv_struct.Channel) - 10u;
   1009              tmpreg3 = tmpreg3 *3u;
   1010              tmpreg2 =  tmpreg4 << (tmpreg3);
   1011              /* Clear the old discontinuous mode channel count */
   1012              tmpreg1 &= ~tmpreg2;
   1013              /* Calculate the mask to set */
   1014              tmpreg2 = (uint32_t)(ADConv_struct.SamplTime) << (tmpreg3);
   1015              /* Set the discontinuous mode channel count */
   1016              tmpreg1 |= tmpreg2;
   1017              /* Store the new register value */
   1018              ADC1->SMPR1 = tmpreg1;
   1019            }
   1020            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1021            {
   1022              /* Get the old register value */
   1023              tmpreg1 = ADC1->SMPR2;
   1024              tmpreg3 = (uint32_t) (ADConv_struct.Channel) * 3u;
   1025              /* Calculate the mask to clear */
   1026              tmpreg4 = SMPR2_SMP_Set;
   1027              tmpreg2 =  tmpreg4 << (tmpreg3);
   1028              /* Clear the old discontinuous mode channel count */
   1029              tmpreg1 &= ~tmpreg2;
   1030              /* Calculate the mask to set */
   1031              tmpreg2 = (uint32_t)(ADConv_struct.SamplTime) << (tmpreg3);
   1032              /* Set the discontinuous mode channel count */
   1033              tmpreg1 |= tmpreg2;
   1034              /* Store the new register value */
   1035              ADC1->SMPR2 = tmpreg1;
   1036            }
   1037          }
   1038          
   1039          /**
   1040          * @brief  It is used to check if an overcurrent occurred since last call.
   1041          * @param  this related object of class CPWMC
   1042          * @retval uint16_t It returns MC_BREAK_IN whether an overcurrent has been 
   1043          *                  detected since last method call, MC_NO_FAULTS otherwise.
   1044          */
   1045          static uint16_t IHD2_IsOverCurrentOccurred(CPWMC this)
   1046          {
   1047            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;
   1048            uint16_t retVal = MC_NO_FAULTS;
   1049            if ((LocalTIMx->SR & TIM_FLAG_Break) != 0u)
   1050            {
   1051              retVal = MC_BREAK_IN;
   1052              LocalTIMx->SR = (u16)~TIM_FLAG_Break;
   1053            }
   1054            return retVal;
   1055          }
   1056          
   1057          /**
   1058          * @}
   1059          */
   1060          
   1061          /**
   1062          * @}
   1063          */
   1064          
   1065          /**
   1066          * @}
   1067          */
   1068          
   1069          #endif
   1070          
   1071          /******************* (C) COPYRIGHT 2015 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   IHD2_ADC_SetSamplingTime
      24   IHD2_CurrentReadingCalibration
        24   -> IHD2_SwitchOffPWM
        24   -> IHD2_SwitchOnPWM
       0   IHD2_ExecRegularConv
       0   IHD2_GetPhaseCurrents
       0   IHD2_HFCurrentsCalibration
      12   IHD2_IRQHandler
     112   IHD2_Init
       112   -> ADC_ClearFlag
       112   -> ADC_Cmd
       112   -> ADC_DMACmd
       112   -> ADC_DeInit
       112   -> ADC_ExternalTrigConvCmd
       112   -> ADC_GetCalibrationStatus
       112   -> ADC_ITConfig
       112   -> ADC_Init
       112   -> ADC_InjectedChannelConfig
       112   -> ADC_InjectedDiscModeCmd
       112   -> ADC_StartCalibration
       112   -> ADC_StructInit
       112   -> DBGMCU_Config
       112   -> DMA_Cmd
       112   -> DMA_DeInit
       112   -> DMA_Init
       112   -> GPIO_Init
       112   -> GPIO_PinLockConfig
       112   -> GPIO_PinRemapConfig
       112   -> GPIO_StructInit
       112   -> IHD2_TIMxInit
       112   -> NVIC_Init
       112   -> RCC_ADCCLKConfig
       112   -> RCC_AHBPeriphClockCmd
       112   -> RCC_APB2PeriphClockCmd
       112   -> RCC_ClockSecuritySystemCmd
       0   IHD2_IsOverCurrentOccurred
      16   IHD2_NewObject
        16   -> PWMC_NewObject
        16   -> Set_IRQ_Handler
      16   IHD2_StartTimers
        16   -> RCC_APB1PeriphClockCmd
        16   -> TIM_Cmd
        16   -> TIM_DeInit
        16   -> TIM_SelectOutputTrigger
        16   -> TIM_TimeBaseInit
        16   -> TIM_TimeBaseStructInit
      16   IHD2_SwitchOffPWM
        16   -> GPIO_WriteBit
        16   -> TIM_CtrlPWMOutputs
        16   -> TIM_GetFlagStatus
        16   -> TIM_ITConfig
      16   IHD2_SwitchOnPWM
        16   -> GPIO_WriteBit
        16   -> TIM_ClearFlag
        16   -> TIM_CtrlPWMOutputs
        16   -> TIM_ITConfig
      80   IHD2_TIMxInit
        80   -> TIM_BDTRConfig
        80   -> TIM_BDTRStructInit
        80   -> TIM_ClearITPendingBit
        80   -> TIM_DeInit
        80   -> TIM_GenerateEvent
        80   -> TIM_ITConfig
        80   -> TIM_OC1Init
        80   -> TIM_OC1PreloadConfig
        80   -> TIM_OC2Init
        80   -> TIM_OC2PreloadConfig
        80   -> TIM_OC3Init
        80   -> TIM_OC3PreloadConfig
        80   -> TIM_OC4Init
        80   -> TIM_OC4PreloadConfig
        80   -> TIM_OCStructInit
        80   -> TIM_SelectInputTrigger
        80   -> TIM_SelectSlaveMode
        80   -> TIM_SetCounter
        80   -> TIM_TimeBaseInit
        80   -> TIM_TimeBaseStructInit
      16   IHD2_TurnOnLowSides
         0   -> GPIO_WriteBit
        16   -> GPIO_WriteBit
        16   -> TIM_ClearFlag
        16   -> TIM_CtrlPWMOutputs
        16   -> TIM_GetFlagStatus
       0   IHD2_WriteTIMRegisters


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_19
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      68  IHD2_ADC_SetSamplingTime
     140  IHD2_CurrentReadingCalibration
      34  IHD2_ExecRegularConv
      80  IHD2_GetPhaseCurrents
      46  IHD2_HFCurrentsCalibration
     112  IHD2_IRQHandler
     784  IHD2_Init
      24  IHD2_IsOverCurrentOccurred
     130  IHD2_NewObject
      52  IHD2_PWMC_Allocated
          IHD2_PWMCpool
      92  IHD2_StartTimers
     116  IHD2_SwitchOffPWM
     120  IHD2_SwitchOnPWM
     472  IHD2_TIMxInit
     114  IHD2_TurnOnLowSides
      60  IHD2_WriteTIMRegisters

 
    52 bytes in section .bss
 2 472 bytes in section .text
 
 2 472 bytes of CODE memory
    52 bytes of DATA memory

Errors: none
Warnings: none
